# streamlit_pattern_ranked.py
# ãƒ‘ã‚¿ãƒ¼ãƒ³èªè­˜ï¼ˆ15ç¨®é¡å¯¾å¿œï¼‰ï¼‹ä¿¡é ¼åº¦ã‚¹ã‚³ã‚¢ä»˜ã

import streamlit as st
import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

st.set_page_config(page_title="æ ªä¾¡ãƒ‘ã‚¿ãƒ¼ãƒ³èªè­˜ï¼†ä¿¡é ¼åº¦", layout="wide")
st.title("ğŸ“Š æ ªä¾¡ãƒ‘ã‚¿ãƒ¼ãƒ³èªè­˜ï¼†ä¿¡é ¼åº¦ä»˜ãäºˆæ¸¬")

# ------------------- ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ -------------------
def safe_last_value(v):
    if isinstance(v, pd.DataFrame):
        if v.empty:
            return None
        return safe_last_value(v.iloc[-1, 0])
    if isinstance(v, pd.Series):
        if v.empty:
            return None
        return safe_last_value(v.iloc[-1])
    if isinstance(v, (list, tuple, np.ndarray)):
        if len(v) == 0:
            return None
        return safe_last_value(v[-1])
    return v

def format_price(v):
    v = safe_last_value(v)
    if v is None:
        return "N/A"
    try:
        return f"{float(v):,.2f}"
    except:
        return str(v)

def pct(a, b):
    try:
        a = float(a)
        b = float(b)
        if a == 0:
            return 0.0
        return abs(a - b) / abs(a) * 100.0
    except:
        return 0.0

def local_extrema_pos(arr: np.ndarray, w: int = 5, kind: str = "max", min_sep: int = 5):
    n = len(arr)
    idxs = []
    last = -10**9
    for i in range(w, n - w):
        left = arr[i - w:i]
        right = arr[i + 1:i + 1 + w]
        if kind == "max":
            if arr[i] >= left.max() and arr[i] >= right.max() and i - last >= min_sep:
                idxs.append(i)
                last = i
        else:
            if arr[i] <= left.min() and arr[i] <= right.min() and i - last >= min_sep:
                idxs.append(i)
                last = i
    return np.array(idxs, dtype=int)

def calc_sma(series: pd.Series, period: int):
    return series.rolling(period, min_periods=1).mean()

def calc_rsi(series: pd.Series, period: int = 14):
    delta = series.diff()
    gain = delta.where(delta > 0, 0.0)
    loss = -delta.where(delta < 0, 0.0)
    avg_gain = gain.rolling(period, min_periods=1).mean()
    avg_loss = loss.rolling(period, min_periods=1).mean()
    rs = avg_gain / (avg_loss.replace(0, np.nan))
    rsi = 100 - (100 / (1 + rs))
    return rsi.fillna(50.0)

# ------------------- ãƒ‘ã‚¿ãƒ¼ãƒ³æ¤œå‡º -------------------
def detect_patterns(df):
    res = []
    highs = df['High'].values
    lows = df['Low'].values
    closes = df['Close'].values

    # ãƒ€ãƒ–ãƒ«ãƒˆãƒƒãƒ—ï¼ãƒœãƒˆãƒ 
    high_idxs = local_extrema_pos(highs, kind='max')
    low_idxs = local_extrema_pos(lows, kind='min')
    # Double Top
    for i in range(len(high_idxs)-1):
        a, b = high_idxs[i], high_idxs[i+1]
        if pct(highs[a], highs[b]) < 3:
            mid_slice = closes[a:b+1]
            neck = lows[a:b+1].min()
            res.append({'name':'ãƒ€ãƒ–ãƒ«ãƒˆãƒƒãƒ—','kind':'ä¸‹è½','points':[a,b],'neckline':neck,'entry':None,'target':highs[a]-neck,'confidence':70})
    # Double Bottom
    for i in range(len(low_idxs)-1):
        a, b = low_idxs[i], low_idxs[i+1]
        if pct(lows[a], lows[b]) < 3:
            mid_slice = closes[a:b+1]
            neck = highs[a:b+1].max()
            res.append({'name':'ãƒ€ãƒ–ãƒ«ãƒœãƒˆãƒ ','kind':'ä¸Šæ˜‡','points':[a,b],'neckline':neck,'entry':neck*0.995,'target':neck+(neck-lows[a]),'confidence':70})

    # ãƒˆãƒªãƒ—ãƒ«ãƒˆãƒƒãƒ—ï¼ãƒœãƒˆãƒ 
    if len(high_idxs)>=3:
        for i in range(len(high_idxs)-2):
            a,b,c = high_idxs[i],high_idxs[i+1],high_idxs[i+2]
            if max(pct(highs[a],highs[b]),pct(highs[b],highs[c]),pct(highs[a],highs[c]))<3:
                neck = lows[a:c+1].min()
                res.append({'name':'ãƒˆãƒªãƒ—ãƒ«ãƒˆãƒƒãƒ—','kind':'ä¸‹è½','points':[a,b,c],'neckline':neck,'entry':None,'target':highs[b]-neck,'confidence':75})
    if len(low_idxs)>=3:
        for i in range(len(low_idxs)-2):
            a,b,c = low_idxs[i],low_idxs[i+1],low_idxs[i+2]
            if max(pct(lows[a],lows[b]),pct(lows[b],lows[c]),pct(lows[a],lows[c]))<3:
                neck = highs[a:c+1].max()
                res.append({'name':'ãƒˆãƒªãƒ—ãƒ«ãƒœãƒˆãƒ ','kind':'ä¸Šæ˜‡','points':[a,b,c],'neckline':neck,'entry':neck*0.995,'target':neck+(neck-lows[b]),'confidence':75})

    # ãƒ˜ãƒƒãƒ‰ã‚¢ãƒ³ãƒ‰ã‚·ãƒ§ãƒ«ãƒ€ãƒ¼ï¼ˆç°¡æ˜“ç‰ˆï¼‰
    peaks = high_idxs
    troughs = low_idxs
    for i in range(len(peaks)-2):
        L,H,R = peaks[i],peaks[i+1],peaks[i+2]
        if highs[H]>highs[L] and highs[H]>highs[R] and pct(highs[L],highs[R])<5:
            neck = (lows[L]+lows[R])/2
            res.append({'name':'ãƒ˜ãƒƒãƒ‰ï¼†ã‚·ãƒ§ãƒ«ãƒ€ãƒ¼ãƒˆãƒƒãƒ—','kind':'ä¸‹è½','points':[L,H,R],'neckline':neck,'entry':None,'target':highs[H]-neck,'confidence':80})
    for i in range(len(troughs)-2):
        L,H,R = troughs[i],troughs[i+1],troughs[i+2]
        if lows[H]<lows[L] and lows[H]<lows[R] and pct(lows[L],lows[R])<5:
            neck = (highs[L]+highs[R])/2
            res.append({'name':'é€†ãƒ˜ãƒƒãƒ‰ï¼†ã‚·ãƒ§ãƒ«ãƒ€ãƒ¼','kind':'ä¸Šæ˜‡','points':[L,H,R],'neckline':neck,'entry':neck*0.995,'target':neck-(lows[H]-neck),'confidence':80})

    # ã‚½ãƒ¼ã‚µãƒ¼å‹ï¼ˆç°¡æ˜“ï¼‰
    window=30
    if len(closes)>window*2:
        for start in range(len(closes)-window):
            seg = closes[start:start+window]
            mid_val = np.median(seg)
            left = np.mean(seg[:window//3])
            right = np.mean(seg[-window//3:])
            if mid_val<left and mid_val<right and (left-mid_val)/left*100>2 and (right-mid_val)/right*100>2:
                target = right+(right-mid_val)
                res.append({'name':'ã‚½ãƒ¼ã‚µãƒ¼ãƒœãƒˆãƒ ','kind':'ä¸Šæ˜‡','points':[start,start+window//2,start+window-1],'neckline':right,'entry':right*0.995,'target':target,'confidence':60})

    return res

# ------------------- Streamlit UI -------------------
st.markdown("éŠ˜æŸ„ã‚³ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦è§£æãƒœã‚¿ãƒ³ã‚’æŠ¼ã™ã¨éå»ãƒãƒ£ãƒ¼ãƒˆã‹ã‚‰ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ¤œå‡ºã—ã€ä¿¡é ¼åº¦é †ã«è¡¨ç¤ºã—ã¾ã™ã€‚")

col1,col2 = st.columns([1,3])
with col1:
    symbol = st.text_input("éŠ˜æŸ„ã‚³ãƒ¼ãƒ‰", "AAPL")
    run = st.button("è§£æ")

with col2:
    placeholder = st.empty()

if run:
    try:
        df = yf.download(symbol, period="1y", interval="1d", progress=False).dropna()
        if df.empty:
            st.error("ãƒ‡ãƒ¼ã‚¿å–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸ")
            st.stop()

        # SMA, RSI
        df['SMA20'] = calc_sma(df['Close'],20)
        df['SMA50'] = calc_sma(df['Close'],50)
        df['RSI'] = calc_rsi(df['Close'])

        patterns = detect_patterns(df)
        if not patterns:
            st.warning("ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯æ¤œå‡ºã•ã‚Œã¾ã›ã‚“ã§ã—ãŸ")
        else:
            # ä¿¡é ¼åº¦é †ã‚½ãƒ¼ãƒˆ
            patterns.sort(key=lambda x:x.get('confidence',50), reverse=True)
            top_patterns = patterns[:5]  # ä¸Šä½5ä»¶
            rows=[]
            for p in top_patterns:
                rows.append({
                    'ãƒ‘ã‚¿ãƒ¼ãƒ³':p['name'],
                    'ç¨®åˆ¥':p['kind'],
                    'ä¿¡é ¼åº¦(%)':p['confidence'],
                    'ãƒãƒƒã‚¯ãƒ©ã‚¤ãƒ³':format_price(p.get('neckline')),
                    'ã‚¨ãƒ³ãƒˆãƒªãƒ¼':format_price(p.get('entry')),
                    'ç›®æ¨™':format_price(p.get('target'))
                })
            st.subheader("ğŸ” ä¿¡é ¼åº¦ä¸Šä½ãƒ‘ã‚¿ãƒ¼ãƒ³")
            st.table(pd.DataFrame(rows))

        # æç”»
        fig,ax=plt.subplots(figsize=(14,6))
        ax.plot(df.index, df['Close'], label='Close', color='tab:blue')
        ax.plot(df.index, df['SMA20'], label='SMA20', color='tab:orange')
        ax.plot(df.index, df['SMA50'], label='SMA50', color='tab:green')
        ax.grid(alpha=0.2)
        ax.set_title(f"{symbol} - éå»1å¹´ã®ãƒãƒ£ãƒ¼ãƒˆ")

        for p in top_patterns:
            pts = p.get('points', [])
            xpts = [df.index[int(pos)] for pos in pts if 0<=int(pos)<len(df)]
            ypts = [float(df['Close'].iloc[int(pos)]) for pos in pts if 0<=int(pos)<len(df)]
            ax.scatter(xpts, ypts, s=60, label=f"{p['name']} ({p['confidence']}%)")
            neck = p.get('neckline')
            if neck is not None:
                ax.axhline(neck, linestyle='--', color='brown')

        ax.legend()
        st.pyplot(fig)

    except Exception as e:
        st.error(f"ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿ: {e}")
