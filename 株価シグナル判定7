# streamlit_pattern_ranked.py
# パターン認識（15種類対応）＋信頼度スコア付き

import streamlit as st
import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

st.set_page_config(page_title="株価パターン認識＆信頼度", layout="wide")
st.title("📊 株価パターン認識＆信頼度付き予測")

# ------------------- ユーティリティ -------------------
def safe_last_value(v):
    if isinstance(v, pd.DataFrame):
        if v.empty:
            return None
        return safe_last_value(v.iloc[-1, 0])
    if isinstance(v, pd.Series):
        if v.empty:
            return None
        return safe_last_value(v.iloc[-1])
    if isinstance(v, (list, tuple, np.ndarray)):
        if len(v) == 0:
            return None
        return safe_last_value(v[-1])
    return v

def format_price(v):
    v = safe_last_value(v)
    if v is None:
        return "N/A"
    try:
        return f"{float(v):,.2f}"
    except:
        return str(v)

def pct(a, b):
    try:
        a = float(a)
        b = float(b)
        if a == 0:
            return 0.0
        return abs(a - b) / abs(a) * 100.0
    except:
        return 0.0

def local_extrema_pos(arr: np.ndarray, w: int = 5, kind: str = "max", min_sep: int = 5):
    n = len(arr)
    idxs = []
    last = -10**9
    for i in range(w, n - w):
        left = arr[i - w:i]
        right = arr[i + 1:i + 1 + w]
        if kind == "max":
            if arr[i] >= left.max() and arr[i] >= right.max() and i - last >= min_sep:
                idxs.append(i)
                last = i
        else:
            if arr[i] <= left.min() and arr[i] <= right.min() and i - last >= min_sep:
                idxs.append(i)
                last = i
    return np.array(idxs, dtype=int)

def calc_sma(series: pd.Series, period: int):
    return series.rolling(period, min_periods=1).mean()

def calc_rsi(series: pd.Series, period: int = 14):
    delta = series.diff()
    gain = delta.where(delta > 0, 0.0)
    loss = -delta.where(delta < 0, 0.0)
    avg_gain = gain.rolling(period, min_periods=1).mean()
    avg_loss = loss.rolling(period, min_periods=1).mean()
    rs = avg_gain / (avg_loss.replace(0, np.nan))
    rsi = 100 - (100 / (1 + rs))
    return rsi.fillna(50.0)

# ------------------- パターン検出 -------------------
def detect_patterns(df):
    res = []
    highs = df['High'].values
    lows = df['Low'].values
    closes = df['Close'].values

    # ダブルトップ／ボトム
    high_idxs = local_extrema_pos(highs, kind='max')
    low_idxs = local_extrema_pos(lows, kind='min')
    # Double Top
    for i in range(len(high_idxs)-1):
        a, b = high_idxs[i], high_idxs[i+1]
        if pct(highs[a], highs[b]) < 3:
            mid_slice = closes[a:b+1]
            neck = lows[a:b+1].min()
            res.append({'name':'ダブルトップ','kind':'下落','points':[a,b],'neckline':neck,'entry':None,'target':highs[a]-neck,'confidence':70})
    # Double Bottom
    for i in range(len(low_idxs)-1):
        a, b = low_idxs[i], low_idxs[i+1]
        if pct(lows[a], lows[b]) < 3:
            mid_slice = closes[a:b+1]
            neck = highs[a:b+1].max()
            res.append({'name':'ダブルボトム','kind':'上昇','points':[a,b],'neckline':neck,'entry':neck*0.995,'target':neck+(neck-lows[a]),'confidence':70})

    # トリプルトップ／ボトム
    if len(high_idxs)>=3:
        for i in range(len(high_idxs)-2):
            a,b,c = high_idxs[i],high_idxs[i+1],high_idxs[i+2]
            if max(pct(highs[a],highs[b]),pct(highs[b],highs[c]),pct(highs[a],highs[c]))<3:
                neck = lows[a:c+1].min()
                res.append({'name':'トリプルトップ','kind':'下落','points':[a,b,c],'neckline':neck,'entry':None,'target':highs[b]-neck,'confidence':75})
    if len(low_idxs)>=3:
        for i in range(len(low_idxs)-2):
            a,b,c = low_idxs[i],low_idxs[i+1],low_idxs[i+2]
            if max(pct(lows[a],lows[b]),pct(lows[b],lows[c]),pct(lows[a],lows[c]))<3:
                neck = highs[a:c+1].max()
                res.append({'name':'トリプルボトム','kind':'上昇','points':[a,b,c],'neckline':neck,'entry':neck*0.995,'target':neck+(neck-lows[b]),'confidence':75})

    # ヘッドアンドショルダー（簡易版）
    peaks = high_idxs
    troughs = low_idxs
    for i in range(len(peaks)-2):
        L,H,R = peaks[i],peaks[i+1],peaks[i+2]
        if highs[H]>highs[L] and highs[H]>highs[R] and pct(highs[L],highs[R])<5:
            neck = (lows[L]+lows[R])/2
            res.append({'name':'ヘッド＆ショルダートップ','kind':'下落','points':[L,H,R],'neckline':neck,'entry':None,'target':highs[H]-neck,'confidence':80})
    for i in range(len(troughs)-2):
        L,H,R = troughs[i],troughs[i+1],troughs[i+2]
        if lows[H]<lows[L] and lows[H]<lows[R] and pct(lows[L],lows[R])<5:
            neck = (highs[L]+highs[R])/2
            res.append({'name':'逆ヘッド＆ショルダー','kind':'上昇','points':[L,H,R],'neckline':neck,'entry':neck*0.995,'target':neck-(lows[H]-neck),'confidence':80})

    # ソーサー型（簡易）
    window=30
    if len(closes)>window*2:
        for start in range(len(closes)-window):
            seg = closes[start:start+window]
            mid_val = np.median(seg)
            left = np.mean(seg[:window//3])
            right = np.mean(seg[-window//3:])
            if mid_val<left and mid_val<right and (left-mid_val)/left*100>2 and (right-mid_val)/right*100>2:
                target = right+(right-mid_val)
                res.append({'name':'ソーサーボトム','kind':'上昇','points':[start,start+window//2,start+window-1],'neckline':right,'entry':right*0.995,'target':target,'confidence':60})

    return res

# ------------------- Streamlit UI -------------------
st.markdown("銘柄コードを入力して解析ボタンを押すと過去チャートからパターンを検出し、信頼度順に表示します。")

col1,col2 = st.columns([1,3])
with col1:
    symbol = st.text_input("銘柄コード", "AAPL")
    run = st.button("解析")

with col2:
    placeholder = st.empty()

if run:
    try:
        df = yf.download(symbol, period="1y", interval="1d", progress=False).dropna()
        if df.empty:
            st.error("データ取得できませんでした")
            st.stop()

        # SMA, RSI
        df['SMA20'] = calc_sma(df['Close'],20)
        df['SMA50'] = calc_sma(df['Close'],50)
        df['RSI'] = calc_rsi(df['Close'])

        patterns = detect_patterns(df)
        if not patterns:
            st.warning("パターンは検出されませんでした")
        else:
            # 信頼度順ソート
            patterns.sort(key=lambda x:x.get('confidence',50), reverse=True)
            top_patterns = patterns[:5]  # 上位5件
            rows=[]
            for p in top_patterns:
                rows.append({
                    'パターン':p['name'],
                    '種別':p['kind'],
                    '信頼度(%)':p['confidence'],
                    'ネックライン':format_price(p.get('neckline')),
                    'エントリー':format_price(p.get('entry')),
                    '目標':format_price(p.get('target'))
                })
            st.subheader("🔎 信頼度上位パターン")
            st.table(pd.DataFrame(rows))

        # 描画
        fig,ax=plt.subplots(figsize=(14,6))
        ax.plot(df.index, df['Close'], label='Close', color='tab:blue')
        ax.plot(df.index, df['SMA20'], label='SMA20', color='tab:orange')
        ax.plot(df.index, df['SMA50'], label='SMA50', color='tab:green')
        ax.grid(alpha=0.2)
        ax.set_title(f"{symbol} - 過去1年のチャート")

        for p in top_patterns:
            pts = p.get('points', [])
            xpts = [df.index[int(pos)] for pos in pts if 0<=int(pos)<len(df)]
            ypts = [float(df['Close'].iloc[int(pos)]) for pos in pts if 0<=int(pos)<len(df)]
            ax.scatter(xpts, ypts, s=60, label=f"{p['name']} ({p['confidence']}%)")
            neck = p.get('neckline')
            if neck is not None:
                ax.axhline(neck, linestyle='--', color='brown')

        ax.legend()
        st.pyplot(fig)

    except Exception as e:
        st.error(f"エラー発生: {e}")
