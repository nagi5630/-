# streamlit_future_30patterns_ai_model_ready.py
import streamlit as st
import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import joblib
import os

# LightGBM
import lightgbm as lgb

st.set_page_config(page_title="æ ªä¾¡30ãƒ‘ã‚¿ãƒ¼ãƒ³æœªæ¥äºˆæ¸¬ï¼ˆAIãƒ¢ãƒ‡ãƒ«å·®è¾¼ç‰ˆï¼‰", layout="wide")
st.title("ğŸ“Š æ ªä¾¡30ãƒ‘ã‚¿ãƒ¼ãƒ³æœªæ¥äºˆæ¸¬ï¼ˆå­¦ç¿’æ¸ˆAIãƒ¢ãƒ‡ãƒ«å¯¾å¿œï¼‰")

# ------------------- ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ -------------------
def safe_last_value(v):
    if isinstance(v, pd.DataFrame) and not v.empty:
        return safe_last_value(v.iloc[-1,0])
    if isinstance(v, pd.Series) and not v.empty:
        return safe_last_value(v.iloc[-1])
    if isinstance(v, (list, tuple, np.ndarray)) and len(v) > 0:
        return safe_last_value(v[-1])
    return v

def format_price(v):
    v = safe_last_value(v)
    return f"{float(v):,.2f}" if v is not None else "N/A"

def calc_sma(series, period=5):
    return series.rolling(period, min_periods=1).mean()

def calc_rsi(series, period=14):
    delta = series.diff()
    gain = delta.where(delta > 0, 0.0)
    loss = -delta.where(delta < 0, 0.0)
    avg_gain = gain.rolling(period, min_periods=1).mean()
    avg_loss = loss.rolling(period, min_periods=1).mean()
    rs = avg_gain / avg_loss.replace(0,np.nan)
    rsi = 100 - (100/(1+rs))
    return rsi.fillna(50.0)

# ------------------- æœªæ¥äºˆæ¸¬ç”Ÿæˆ -------------------
def generate_future(df, days=5):
    last = safe_last_value(df['Close'])
    future_dates = pd.date_range(df.index[-1]+pd.Timedelta(days=1), periods=days)
    future_series = pd.Series([last]*days, index=future_dates)
    return future_series

# ------------------- ç‰¹å¾´é‡æŠ½å‡º -------------------
def extract_features(df):
    features = pd.DataFrame()
    features['Close'] = df['Close']
    features['SMA5'] = calc_sma(df['Close'],5)
    features['SMA10'] = calc_sma(df['Close'],10)
    features['SMA20'] = calc_sma(df['Close'],20)
    features['RSI14'] = calc_rsi(df['Close'],14)
    features['Diff1'] = df['Close'].diff()
    features['Diff2'] = df['Close'].diff(2)
    features = features.fillna(method='bfill').fillna(0)
    return features

# ------------------- 30ãƒ‘ã‚¿ãƒ¼ãƒ³å -------------------
pattern_names = [
    "ãƒ€ãƒ–ãƒ«ãƒˆãƒƒãƒ—", "ãƒ€ãƒ–ãƒ«ãƒœãƒˆãƒ ", "ãƒˆãƒªãƒ—ãƒ«ãƒˆãƒƒãƒ—", "ãƒˆãƒªãƒ—ãƒ«ãƒœãƒˆãƒ ",
    "ãƒ˜ãƒƒãƒ‰ï¼†ã‚·ãƒ§ãƒ«ãƒ€ãƒ¼", "é€†ãƒ˜ãƒƒãƒ‰ï¼†ã‚·ãƒ§ãƒ«ãƒ€ãƒ¼", "ã‚½ãƒ¼ã‚µãƒ¼ãƒˆãƒƒãƒ—", "ã‚½ãƒ¼ã‚µãƒ¼ãƒœãƒˆãƒ ",
    "ä¸Šæ˜‡ãƒšãƒŠãƒ³ãƒˆ", "ä¸‹é™ãƒšãƒŠãƒ³ãƒˆ", "ä¸Šæ˜‡ãƒ•ãƒ©ãƒƒã‚°", "ä¸‹é™ãƒ•ãƒ©ãƒƒã‚°",
    "ä¸Šæ˜‡ãƒãƒ£ãƒãƒ«", "ä¸‹é™ãƒãƒ£ãƒãƒ«", "ãƒ¬ãƒ³ã‚¸ä¸Šé™åç™º", "ãƒ¬ãƒ³ã‚¸ä¸‹é™åç™º",
    "ãƒ–ãƒ¬ã‚¤ã‚¯ã‚¢ã‚¦ãƒˆä¸Šæ˜‡", "ãƒ–ãƒ¬ã‚¤ã‚¯ã‚¢ã‚¦ãƒˆä¸‹è½", "Vå­—å›å¾©", "Vå­—ä¸‹è½",
    "Wå­—åº•", "Må­—å¤©äº•", "ãƒ©ã‚¦ãƒ³ãƒ‰ãƒˆãƒƒãƒ—", "ãƒ©ã‚¦ãƒ³ãƒ‰ãƒœãƒˆãƒ ",
    "ä¸‰è§’æŒã¡åˆã„ä¸Šæ˜‡", "ä¸‰è§’æŒã¡åˆã„ä¸‹è½", "ä¸‹é™ã‚¦ã‚§ãƒƒã‚¸", "ä¸Šæ˜‡ã‚¦ã‚§ãƒƒã‚¸",
    "ã‚¬ãƒƒãƒ‘ãƒ¼ä¸Šæ˜‡", "ã‚¬ãƒƒãƒ‘ãƒ¼ä¸‹è½"
]

# ------------------- AIãƒ¢ãƒ‡ãƒ«ã§äºˆæ¸¬ -------------------
def model_predict(pattern_name, last_price, df, model_dict):
    if pattern_name not in model_dict:
        future_val = last_price * (1 + np.random.randn()*0.02)
        confidence = np.random.randint(50,95)
        return future_val, confidence
    
    model = model_dict[pattern_name]
    features = extract_features(df).iloc[-1].values.reshape(1,-1)
    prob = model.predict_proba(features)[0]
    confidence = int(prob[1]*100)
    future_val = last_price * (1 + (prob[1]-0.5)*0.04)
    return future_val, confidence

# ------------------- 30ãƒ‘ã‚¿ãƒ¼ãƒ³åˆ¤å®š -------------------
def detect_patterns_future(future_series, df, model_dict):
    patterns = []
    last_price = safe_last_value(future_series)
    if last_price is None:
        return patterns
    for name in pattern_names:
        future_val, confidence = model_predict(name, last_price, df, model_dict)
        entry = last_price * 0.995
        target = future_val
        stop = last_price * 0.99
        kind = 'ä¸Šæ˜‡' if future_val > last_price else 'ä¸‹è½'
        patterns.append({
            'name': name,
            'kind': kind,
            'entry': entry,
            'target': target,
            'stop': stop,
            'confidence': confidence,
            'future_val': future_val
        })
    patterns.sort(key=lambda x:x['confidence'], reverse=True)
    return patterns

# ------------------- Streamlit UI -------------------
st.markdown("""
ç›´è¿‘ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰30ç¨®ã®ãƒãƒ£ãƒ¼ãƒˆå½¢çŠ¶ã‚’æœªæ¥äºˆæ¸¬ï¼ˆå­¦ç¿’æ¸ˆAIãƒ¢ãƒ‡ãƒ«å·®è¾¼ç‰ˆï¼‰ã—ã€
ã‚¨ãƒ³ãƒˆãƒªãƒ¼/åˆ©ç¢º/æåˆ‡ã‚Šã®ç›®å®‰ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚
""")

col1,col2 = st.columns([1,3])
with col1:
    symbol = st.text_input("éŠ˜æŸ„ã‚³ãƒ¼ãƒ‰", "AAPL")
    future_days = st.selectbox("æœªæ¥äºˆæ¸¬æ—¥æ•°", [5, 10])
    run = st.button("äºˆæ¸¬é–‹å§‹")

with col2:
    placeholder = st.empty()

# ------------------- å­¦ç¿’æ¸ˆãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿ -------------------
model_dict = {}
for name in pattern_names:
    model_file = f"model_{name.replace('ï¼†','and').replace(' ','_')}.pkl"
    if os.path.exists(model_file):
        model_dict[name] = joblib.load(model_file)

if run:
    try:
        df = yf.download(symbol, period="1y", interval="1d", progress=False).dropna()
        if df is None or df.empty:
            st.error("ãƒ‡ãƒ¼ã‚¿å–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸ")
            st.stop()

        future_series = generate_future(df, days=future_days)
        if future_series.empty:
            st.error("æœªæ¥äºˆæ¸¬ãŒç”Ÿæˆã§ãã¾ã›ã‚“ã§ã—ãŸ")
            st.stop()

        patterns = detect_patterns_future(future_series, df, model_dict)
        top_patterns = patterns[:10]

        # è¡¨ç¤ºç”¨ãƒ†ãƒ¼ãƒ–ãƒ«
        rows=[]
        for p in top_patterns:
            rows.append({
                'ãƒ‘ã‚¿ãƒ¼ãƒ³': p['name'],
                'ç¨®åˆ¥': p['kind'],
                'ä¿¡é ¼åº¦(%)': p['confidence'],
                'ã‚¨ãƒ³ãƒˆãƒªãƒ¼': format_price(p['entry']),
                'åˆ©ç¢º': format_price(p['target']),
                'æåˆ‡ã‚Š': format_price(p['stop']),
                'æœªæ¥äºˆæ¸¬ä¾¡æ ¼': format_price(p['future_val'])
            })
        st.subheader("ğŸ” ä¿¡é ¼åº¦ä¸Šä½ãƒ‘ã‚¿ãƒ¼ãƒ³")
        st.table(pd.DataFrame(rows))

        # ãƒãƒ£ãƒ¼ãƒˆæç”»
        fig,ax = plt.subplots(figsize=(14,6))
        ax.plot(df.index, df['Close'], label='ç¾åœ¨ä¾¡æ ¼', color='blue')
        ax.plot(future_series.index, future_series.values, label='æœªæ¥äºˆæ¸¬', linestyle='--', color='red', marker='o')
        for p in top_patterns:
            ax.annotate(p['name'],
                        xy=(future_series.index[-1], p['future_val']),
                        xytext=(future_series.index[-1], p['future_val']*1.01),
                        arrowprops=dict(facecolor='red', shrink=0.05))
        ax.grid(alpha=0.2)
        ax.set_title(f"{symbol} - æœªæ¥{future_days}æ—¥äºˆæ¸¬ï¼ˆAIãƒ¢ãƒ‡ãƒ«å·®è¾¼ç‰ˆï¼‰")
        ax.legend()
        st.pyplot(fig)

    except Exception as e:
        st.error(f"ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿ: {e}")

