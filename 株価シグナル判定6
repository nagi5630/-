# streamlit_pattern_15_complete.py
# å¿…è¦ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸: streamlit, yfinance, pandas, numpy, matplotlib
# å®Ÿè¡Œ: streamlit run streamlit_pattern_15_complete.py

import streamlit as st
import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from datetime import timedelta

st.set_page_config(page_title="æ ªä¾¡ 15 ãƒ‘ã‚¿ãƒ¼ãƒ³æ¤œå‡ºï¼†æœªæ¥äºˆæ¸¬", layout="wide")
st.title("ğŸ“Š æ ªä¾¡ 15ãƒ‘ã‚¿ãƒ¼ãƒ³æ¤œå‡º ï¼† æœªæ¥äºˆæ¸¬ (ãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹)")

# -------------------------
# ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°
# -------------------------
def safe_float(x):
    try:
        return float(x)
    except Exception:
        return None

def format_price_num(x):
    v = safe_float(x)
    return "N/A" if v is None else f"{v:,.2f}"

def to_list_datetime(index):
    """DatetimeIndex -> list[datetime]"""
    try:
        return list(index.to_pydatetime())
    except Exception:
        return list(index)

def simple_peaks(arr: np.ndarray, distance: int = 5, kind: str = "max"):
    """
    é scipy ç°¡æ˜“ãƒ”ãƒ¼ã‚¯/ãƒˆãƒ©ãƒ•æ¤œå‡ºã€‚
    kind: "max" or "min"
    distance: æœ€å°é–“éš”
    return: numpy.array of positions (ints)
    """
    n = len(arr)
    idxs = []
    if n <= distance * 2:
        return np.array([], dtype=int)
    for i in range(distance, n - distance):
        left = arr[i - distance:i]
        right = arr[i + 1:i + 1 + distance]
        if kind == "max":
            if arr[i] >= left.max() and arr[i] >= right.max():
                idxs.append(i)
        else:
            if arr[i] <= left.min() and arr[i] <= right.min():
                idxs.append(i)
    return np.array(idxs, dtype=int)

# -------------------------
# ãƒ‘ã‚¿ãƒ¼ãƒ³æ¤œå‡º(15ç¨®)
# ã™ã¹ã¦ä½ç½®(æ•´æ•°index)/float ã‚’æ‰±ã†ã€‚Series ã¯ç›´æ¥ if åˆ¤å®šã—ãªã„ã€‚
# -------------------------
def detect_double_top(df, window_recent=60, tol_pct=0.03):
    res = []
    closes = df['Close'].values
    n = len(closes)
    if n < 30: 
        return res
    start = max(0, n - window_recent)
    arr = closes[start:]
    peaks = simple_peaks(arr, distance=4, kind='max')
    if len(peaks) >= 2:
        for i in range(len(peaks) - 1):
            a = start + int(peaks[i])
            b = start + int(peaks[i+1])
            pa = float(closes[a]); pb = float(closes[b])
            if pa <= 0: continue
            if abs(pa - pb) / pa <= tol_pct:
                neckline_val = float(np.min(closes[a:b+1]))
                height = max(pa, pb) - neckline_val
                target = neckline_val - height
                invalid = neckline_val * 1.01
                res.append({
                    'name': 'ãƒ€ãƒ–ãƒ«ãƒˆãƒƒãƒ—',
                    'kind': 'ä¸‹é™',
                    'points': [a,b],
                    'entry': float(closes[-1]),
                    'target': float(target),
                    'invalidation': float(invalid),
                    'info': f"peaks idx {a},{b}, neckline {format_price_num(neckline_val)}"
                })
    return res

def detect_double_bottom(df, window_recent=60, tol_pct=0.03):
    res = []
    closes = df['Close'].values
    n = len(closes)
    if n < 30:
        return res
    start = max(0, n - window_recent)
    arr = closes[start:]
    troughs = simple_peaks(arr, distance=4, kind='min')
    if len(troughs) >= 2:
        for i in range(len(troughs) - 1):
            a = start + int(troughs[i])
            b = start + int(troughs[i+1])
            pa = float(closes[a]); pb = float(closes[b])
            if pa <= 0: continue
            if abs(pa - pb) / pa <= tol_pct:
                neckline_val = float(np.max(closes[a:b+1]))
                height = neckline_val - min(pa,pb)
                target = neckline_val + height
                invalid = min(pa,pb) * 0.99
                res.append({
                    'name': 'ãƒ€ãƒ–ãƒ«ãƒœãƒˆãƒ ',
                    'kind': 'ä¸Šæ˜‡',
                    'points': [a,b],
                    'entry': float(closes[-1]),
                    'target': float(target),
                    'invalidation': float(invalid),
                    'info': f"troughs idx {a},{b}, neckline {format_price_num(neckline_val)}"
                })
    return res

def detect_triple_top(df, window_recent=90, tol_pct=0.03):
    res = []
    closes = df['Close'].values; n = len(closes)
    if n < 50: return res
    start = max(0, n - window_recent)
    arr = closes[start:]
    peaks = simple_peaks(arr, distance=4, kind='max')
    if len(peaks) >= 3:
        for i in range(len(peaks)-2):
            a = start + int(peaks[i]); b = start + int(peaks[i+1]); c = start + int(peaks[i+2])
            pa, pb, pc = float(closes[a]), float(closes[b]), float(closes[c])
            if pa <= 0: continue
            if max(abs(pa-pb)/pa, abs(pb-pc)/pb, abs(pa-pc)/pa) <= tol_pct:
                neckline_val = float(np.min(closes[a:c+1]))
                height = max(pa,pb,pc) - neckline_val
                target = neckline_val - height
                invalid = neckline_val * 1.01
                res.append({
                    'name': 'ãƒˆãƒªãƒ—ãƒ«ãƒˆãƒƒãƒ—',
                    'kind': 'ä¸‹é™',
                    'points': [a,b,c],
                    'entry': float(closes[-1]),
                    'target': float(target),
                    'invalidation': float(invalid),
                    'info': f"peaks idx {a},{b},{c}"
                })
    return res

def detect_triple_bottom(df, window_recent=90, tol_pct=0.03):
    res = []
    closes = df['Close'].values; n = len(closes)
    if n < 50: return res
    start = max(0, n - window_recent)
    arr = closes[start:]
    troughs = simple_peaks(arr, distance=4, kind='min')
    if len(troughs) >= 3:
        for i in range(len(troughs)-2):
            a = start + int(troughs[i]); b = start + int(troughs[i+1]); c = start + int(troughs[i+2])
            pa, pb, pc = float(closes[a]), float(closes[b]), float(closes[c])
            if pa <= 0: continue
            if max(abs(pa-pb)/pa, abs(pb-pc)/pb, abs(pa-pc)/pa) <= tol_pct:
                neckline_val = float(np.max(closes[a:c+1]))
                height = neckline_val - min(pa,pb,pc)
                target = neckline_val + height
                invalid = min(pa,pb,pc) * 0.99
                res.append({
                    'name': 'ãƒˆãƒªãƒ—ãƒ«ãƒœãƒˆãƒ ',
                    'kind': 'ä¸Šæ˜‡',
                    'points': [a,b,c],
                    'entry': float(closes[-1]),
                    'target': float(target),
                    'invalidation': float(invalid),
                    'info': f"troughs idx {a},{b},{c}"
                })
    return res

def detect_head_and_shoulders_top(df, window_recent=120, tol_pct=0.08):
    res = []
    closes = df['Close'].values; n=len(closes)
    if n < 60: return res
    start = max(0, n - window_recent)
    arr = closes[start:]
    peaks = simple_peaks(arr, distance=4, kind='max')
    troughs = simple_peaks(arr, distance=4, kind='min')
    if len(peaks) >= 3:
        for i in range(len(peaks)-2):
            L = start + int(peaks[i]); H = start + int(peaks[i+1]); R = start + int(peaks[i+2])
            pL, pH, pR = float(closes[L]), float(closes[H]), float(closes[R])
            if pH > pL and pH > pR and abs(pL - pR) / pL <= tol_pct:
                # neckline: average of two troughs between L-H and H-R (if present)
                left_trough_idx = None
                right_trough_idx = None
                # search for min between L and H
                if H - L > 1:
                    left_trough_idx = int(L + np.argmin(closes[L:H+1]))
                if R - H > 1:
                    right_trough_idx = int(H + 1 + np.argmin(closes[H+1:R+1]))
                if left_trough_idx is not None and right_trough_idx is not None:
                    nl_y1 = float(closes[left_trough_idx]); nl_y2 = float(closes[right_trough_idx])
                    neckline = (nl_y1 + nl_y2) / 2.0
                    height = pH - neckline
                    target = neckline - height
                    invalid = max(nl_y1, nl_y2) * 1.02
                    res.append({
                        'name': 'ãƒ˜ãƒƒãƒ‰ï¼†ã‚·ãƒ§ãƒ«ãƒ€ãƒ¼ãƒ»ãƒˆãƒƒãƒ—',
                        'kind': 'ä¸‹é™',
                        'points': [L,H,R],
                        'entry': float(closes[-1]),
                        'target': float(target),
                        'invalidation': float(invalid),
                        'info': f"neck {format_price_num(neckline)}"
                    })
    return res

def detect_head_and_shoulders_bottom(df, window_recent=120, tol_pct=0.08):
    res = []
    closes = df['Close'].values; n=len(closes)
    if n < 60: return res
    start = max(0, n - window_recent)
    arr = closes[start:]
    troughs = simple_peaks(arr, distance=4, kind='min')
    peaks = simple_peaks(arr, distance=4, kind='max')
    if len(troughs) >= 3:
        for i in range(len(troughs)-2):
            L = start + int(troughs[i]); H = start + int(troughs[i+1]); R = start + int(troughs[i+2])
            pL, pH, pR = float(closes[L]), float(closes[H]), float(closes[R])
            if pH < pL and pH < pR and abs(pL - pR) / pL <= tol_pct:
                # neckline peaks between L-H and H-R
                left_peak_idx = None
                right_peak_idx = None
                if H - L > 1:
                    left_peak_idx = int(L + np.argmax(closes[L:H+1]))
                if R - H > 1:
                    right_peak_idx = int(H + 1 + np.argmax(closes[H+1:R+1]))
                if left_peak_idx is not None and right_peak_idx is not None:
                    nl_y1 = float(closes[left_peak_idx]); nl_y2 = float(closes[right_peak_idx])
                    neckline = (nl_y1 + nl_y2) / 2.0
                    height = neckline - pH
                    target = neckline + height
                    invalid = pH * 0.99
                    res.append({
                        'name': 'ãƒ˜ãƒƒãƒ‰ï¼†ã‚·ãƒ§ãƒ«ãƒ€ãƒ¼ãƒ»ãƒœãƒˆãƒ ',
                        'kind': 'ä¸Šæ˜‡',
                        'points': [L,H,R],
                        'entry': float(closes[-1]),
                        'target': float(target),
                        'invalidation': float(invalid),
                        'info': f"neck {format_price_num(nl_y1)} & {format_price_num(nl_y2)}"
                    })
    return res

def detect_saucer_top_bottom(df, window=30):
    res = []
    closes = df['Close'].values; n = len(closes)
    if n < window*2: return res
    # sliding windows to find saucer-like shapes near the end
    for start in range(max(0,n-window*3), n-window):
        seg = closes[start:start+window]
        left = np.mean(seg[:max(1,window//3)])
        mid = np.mean(seg[window//3:window*2//3])
        right = np.mean(seg[-max(1,window//3):])
        # saucer bottom
        if mid < left and mid < right and (left - mid)/left > 0.02 and (right - mid)/right > 0.02:
            entry = float(closes[-1])
            neckline = float(right)
            height = neckline - mid
            target = neckline + height
            invalid = float(mid * 0.98)
            res.append({
                'name':'ã‚½ãƒ¼ã‚µãƒ¼ãƒœãƒˆãƒ ',
                'kind':'ä¸Šæ˜‡',
                'points':[start, start+window//2, start+window-1],
                'entry': entry,
                'target': float(target),
                'invalidation': float(invalid),
                'info': f"saucer start {start}"
            })
        # saucer top
        if mid > left and mid > right and (mid - left)/left > 0.02 and (mid - right)/right > 0.02:
            entry = float(closes[-1])
            neckline = float(right)
            height = mid - neckline
            target = neckline - height
            invalid = float(mid * 1.02)
            res.append({
                'name':'ã‚½ãƒ¼ã‚µãƒ¼ãƒˆãƒƒãƒ—',
                'kind':'ä¸‹é™',
                'points':[start, start+window//2, start+window-1],
                'entry': entry,
                'target': float(target),
                'invalidation': float(invalid),
                'info': f"saucer start {start}"
            })
    return res

def detect_triangles_and_boxes(df):
    """
    ä¸Šæ˜‡/ä¸‹é™ä¸‰è§’ã€ãƒœãƒƒã‚¯ã‚¹ï¼ˆãƒ¬ãƒ³ã‚¸ï¼‰ã‚’ç°¡æ˜“åˆ¤å®šã€‚
    - ä¸Šæ˜‡ä¸‰è§’: é«˜å€¤ã¯æ¨ªã°ã„ or slight down, å®‰å€¤ã¯åˆ‡ã‚Šä¸Šã’
    - ä¸‹é™ä¸‰è§’: å®‰å€¤ã¯æ¨ªã°ã„, é«˜å€¤ã¯åˆ‡ã‚Šä¸‹ã’
    - ãƒœãƒƒã‚¯ã‚¹: ä¾¡æ ¼ãƒ¬ãƒ³ã‚¸ãŒç‹­ã„
    """
    res = []
    closes = df['Close'].values; highs = df['High'].values; lows = df['Low'].values
    n = len(closes)
    if n < 30: return res
    N = min(60, n)
    sub_h = highs[-N:]; sub_l = lows[-N:]; sub_c = closes[-N:]
    # linear fit
    x = np.arange(len(sub_c))
    # highs trend
    try:
        kh, bh = np.polyfit(x, sub_h, 1)
        kl, bl = np.polyfit(x, sub_l, 1)
    except Exception:
        return res
    # box: range small
    rng = sub_h.max() - sub_l.min()
    avg = sub_c.mean()
    if avg > 0 and (rng / avg) < 0.06:
        res.append({
            'name': 'ãƒœãƒƒã‚¯ã‚¹(ãƒ¬ãƒ³ã‚¸)',
            'kind': 'æ¨ªã°ã„',
            'entry': float(closes[-1]),
            'target': float(sub_h.max()),
            'invalidation': float(sub_h.max() * 1.02),
            'info': f"range {format_price_num(rng)}"
        })
    # triangle checks: if upper slope ~ 0 and lower slope > 0 -> ascending triangle
    if abs(kh) < 0.001 and kl > 0.0:
        # ascending triangle -> breakout up
        entry = float(closes[-1])
        target = float(entry + (sub_h.max()-sub_l.min()))
        res.append({
            'name': 'ä¸Šæ˜‡ä¸‰è§’ä¿ã¡åˆã„',
            'kind': 'ä¸Šæ˜‡',
            'entry': entry,
            'target': target,
            'invalidation': float(sub_l.min()*0.99),
            'info': f"kh {kh:.4f}, kl {kl:.4f}"
        })
    if abs(kl) < 0.001 and kh < 0.0:
        entry = float(closes[-1])
        target = float(entry - (sub_h.max()-sub_l.min()))
        res.append({
            'name': 'ä¸‹é™ä¸‰è§’ä¿ã¡åˆã„',
            'kind': 'ä¸‹é™',
            'entry': entry,
            'target': target,
            'invalidation': float(sub_h.max()*1.01),
            'info': f"kh {kh:.4f}, kl {kl:.4f}"
        })
    # wedges (ç²—ã„åˆ¤å®š): both slopes positive but upper slope < lower slope -> rising wedge (bearish)
    if kh > 0 and kl > 0 and kl > kh * 1.2:
        entry = float(closes[-1])
        target = float(entry - (sub_h.max()-sub_l.min())*0.6)
        res.append({
            'name': 'ä¸Šæ˜‡ã‚¦ã‚§ãƒƒã‚¸',
            'kind': 'ä¸‹é™',
            'entry': entry,
            'target': target,
            'invalidation': float(sub_h.max()*1.02),
            'info': f"wedge rising kh {kh:.4f}, kl {kl:.4f}"
        })
    if kh < 0 and kl < 0 and abs(kh) > abs(kl) * 1.2:
        entry = float(closes[-1])
        target = float(entry + (sub_h.max()-sub_l.min())*0.6)
        res.append({
            'name': 'ä¸‹é™ã‚¦ã‚§ãƒƒã‚¸',
            'kind': 'ä¸Šæ˜‡',
            'entry': entry,
            'target': target,
            'invalidation': float(sub_l.min()*0.99),
            'info': f"wedge falling kh {kh:.4f}, kl {kl:.4f}"
        })
    # flags simple: recent trend strong then consolidation -> continuation
    recent = sub_c
    if recent[-1] > recent[0] * 1.05:
        res.append({
            'name': 'ä¸Šæ˜‡ãƒ•ãƒ©ãƒƒã‚°',
            'kind': 'ä¸Šæ˜‡',
            'entry': float(closes[-1]),
            'target': float(closes[-1]*1.05),
            'invalidation': float(sub_l.min()*0.99),
            'info': 'recent up consolidation'
        })
    if recent[-1] < recent[0] * 0.95:
        res.append({
            'name': 'ä¸‹é™ãƒ•ãƒ©ãƒƒã‚°',
            'kind': 'ä¸‹é™',
            'entry': float(closes[-1]),
            'target': float(closes[-1]*0.95),
            'invalidation': float(sub_h.max()*1.01),
            'info': 'recent down consolidation'
        })
    return res

# -------------------------
# ã¾ã¨ã‚ã¦å…¨æ¤œå‡ºã™ã‚‹é–¢æ•°
# -------------------------
def detect_all_patterns(df):
    patterns = []
    patterns += detect_double_top(df)
    patterns += detect_double_bottom(df)
    patterns += detect_triple_top(df)
    patterns += detect_triple_bottom(df)
    patterns += detect_head_and_shoulders_top(df)
    patterns += detect_head_and_shoulders_bottom(df)
    patterns += detect_saucer_top_bottom(df)
    patterns += detect_triangles_and_boxes(df)
    # dedupe by name+target (approx)
    unique = []
    seen = set()
    for p in patterns:
        key = (p.get('name'), round(safe_float(p.get('target') or 0), 2))
        if key not in seen:
            seen.add(key)
            unique.append(p)
    # sort by simple heuristic: kind: ä¸Šæ˜‡/ä¸‹é™ first, then confidence by presence (no explicit conf here)
    return unique

# -------------------------
# äºˆæ¸¬ã®ãŸã‚ã®å˜ç´”ãƒ¢ãƒ‡ãƒ«ï¼ˆéå»ã®å¹³å‡ãƒªã‚¿ãƒ¼ãƒ³ãƒ™ãƒ¼ã‚¹ï¼‰
# -------------------------
def forecast_simple(data, periods=10):
    # periods: number of future business days
    # compute mean daily pct change over recent window
    recent = data['Close'].pct_change().dropna().iloc[-60:]
    if len(recent) == 0:
        return []
    mean_ret = float(recent.mean())
    last = float(data['Close'].iloc[-1])
    preds = [last]
    for _ in range(periods):
        preds.append(preds[-1] * (1 + mean_ret))
    return preds  # length periods+1, first is last price

# -------------------------
# Streamlit UI
# -------------------------
col1, col2 = st.columns([1,3])
with col1:
    symbol = st.text_input("éŠ˜æŸ„ã‚³ãƒ¼ãƒ‰ (ä¾‹: AAPL, 7203.T)", "AAPL")
    period = st.selectbox("å–å¾—æœŸé–“", ["6mo","1y","2y","5y"], index=1)
    run = st.button("è§£æãƒ»15ãƒ‘ã‚¿ãƒ¼ãƒ³æ¤œå‡º")
    st.markdown("""
    ãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ã§15ç¨®é¡ã®ãƒãƒ£ãƒ¼ãƒˆãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ç°¡æ˜“æ¤œå‡ºã—ã¾ã™ã€‚\n
    â€» è‡ªå‹•æ¤œå‡ºã¯è¿‘ä¼¼çš„ã§ã™ã€‚å®Ÿå–å¼•ã§ã¯å¿…ãšè‡ªèº«ã§ç¢ºèªã—ã¦ãã ã•ã„ã€‚
    """)

with col2:
    placeholder = st.empty()

if run:
    try:
        df = yf.download(symbol, period=period, interval="1d", progress=False)
        if df is None or df.empty:
            st.error("ãƒ‡ãƒ¼ã‚¿ãŒå–å¾—ã§ãã¾ã›ã‚“ã€‚ãƒ†ã‚£ãƒƒã‚«ãƒ¼ã‚„æœŸé–“ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚")
            st.stop()
        df = df.dropna()
        if len(df) < 30:
            st.error("ãƒ‡ãƒ¼ã‚¿ãŒçŸ­ã™ãã¾ã™ã€‚æœŸé–“ã‚’é•·ãã—ã¦ãã ã•ã„ã€‚")
            st.stop()

        patterns = detect_all_patterns(df)

        # prepare plotting arrays (ensure 1-D lists)
        past_dates = to_list_datetime(df.index)
        past_closes = list(df['Close'].values)

        future_days = 10
        # future business days
        last_date = df.index[-1]
        future_idx = pd.date_range(last_date, periods=future_days+1, freq='B')[1:]
        future_dates = list(future_idx.to_pydatetime())

        # forecast baseline
        forecast_vals = forecast_simple(df, periods=future_days)
        # forecast_vals is [last_price, p1, p2, ...]
        forecast_dates = [past_dates[-1]] + future_dates
        forecast_vals_plot = list(forecast_vals)

        # Plot
        fig, ax = plt.subplots(figsize=(14,7))
        ax.plot(past_dates, past_closes, color='black', linewidth=1.3, label='éå»çµ‚å€¤')
        # baseline forecast
        ax.plot(forecast_dates, forecast_vals_plot, color='tab:gray', linestyle='--', label='ç°¡æ˜“äºˆæ¸¬(å¹³å‡ãƒªã‚¿ãƒ¼ãƒ³)')

        # overlay pattern predictions
        legend_entries = set()
        for p in patterns:
            name = p.get('name')
            kind = p.get('kind')
            entry = safe_float(p.get('entry'))
            target = safe_float(p.get('target'))
            invalid = safe_float(p.get('invalidation'))
            info = p.get('info', "")
            color = 'tab:green' if kind in ('ä¸Šæ˜‡','ç¶™ç¶š(ä¸Š)','ç¶™ç¶š') else 'tab:red'

            # ensure x,y are 1-D lists
            x_plot = [past_dates[-1]] + future_dates
            # if target is None, fallback to baseline forecast last value
            if target is None:
                y_plot = [entry] + [forecast_vals_plot[-1]] * len(future_dates)
            else:
                y_plot = [entry] + [target] * len(future_dates)

            x_plot = list(x_plot)
            y_plot = list(y_plot)

            ax.plot(x_plot, y_plot, linestyle='--', linewidth=2, color=color)
            if invalid is not None:
                ax.axhline(invalid, linestyle=':', linewidth=1, color='tab:orange')

            # add text label near last point (offset)
            try:
                ax.text(past_dates[-1] + timedelta(days=1), y_plot[1], f"{name}\nT:{format_price_num(target)}", fontsize=8)
            except Exception:
                pass

            # add legend markers once
            label_pred = f"{name} äºˆæ¸¬"
            if label_pred not in legend_entries:
                ax.plot([], [], linestyle='--', color=color, label=label_pred)
                legend_entries.add(label_pred)

        ax.set_title(f"{symbol} - éå»ã¨ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒ™ãƒ¼ã‚¹äºˆæ¸¬ ({period})")
        ax.set_xlabel("Date")
        ax.set_ylabel("Price")
        ax.grid(alpha=0.25)
        ax.legend(loc='upper left', fontsize='small')
        st.pyplot(fig)

        # show table of detected patterns
        if patterns:
            st.subheader("ğŸ” æ¤œå‡ºã•ã‚ŒãŸãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆå€™è£œï¼‰")
            df_pat = pd.DataFrame(patterns)
            # ensure display-friendly formatting
            if 'target' in df_pat.columns:
                df_pat['entry'] = df_pat['entry'].apply(format_price_num)
                df_pat['target'] = df_pat['target'].apply(format_price_num)
                df_pat['invalidation'] = df_pat['invalidation'].apply(format_price_num)
            st.table(df_pat[['name','kind','entry','target','invalidation','info']])
        else:
            st.info("ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯æ¤œå‡ºã•ã‚Œã¾ã›ã‚“ã§ã—ãŸï¼ˆé–¾å€¤ãƒ»æœŸé–“ã‚’èª¿æ•´ã—ã¦ãã ã•ã„ï¼‰ã€‚")

    except Exception as e:
        st.error(f"ã‚¨ãƒ©ãƒ¼: {e}")
